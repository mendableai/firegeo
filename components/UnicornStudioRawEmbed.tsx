"use client";
import { useEffect, useRef } from "react";

const UNICORN_SCRIPT_SRC = "https://cdn.jsdelivr.net/gh/hiunicornstudio/unicornstudio.js@v1.4.28/dist/unicornStudio.umd.js";

// To change the width of the effect, you can adjust the 'width' property in the style below.
// However, for changes to the actual effect's appearance (e.g., the effect's internal width, aspect ratio, or shader),
// you must update the scene in Unicorn Studio and re-export the config JSON.
const SCENE_CONFIG = {"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":8.714285714285714,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":["71bb708a-ecd8-48d4-8919-1175e974b5e0","7a55e45c-6061-49ef-a501-c6b0a931022a"],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"translateX":-30,"translateY":239,"layerType":"text","justCreated":false,"isSafari":false,"width":0.8804591605141793,"widthMode":"relative","height":145.4922678357857,"heightMode":"fixed","left":0.5016436025468203,"leftMode":"relative","top":0.5003203629981541,"topMode":"relative","rotation":0,"fontSize":0.07361215932167729,"lineHeight":1.3725490196078431,"letterSpacing":-0.028301483783805183,"fontFamily":"Departure Mono","fontStyle":"regular","fontWeight":"400","textAlign":"center","textContent":"AI SENSE MAKING","fill":["#00BEF8"],"gradientAngle":0,"gradientType":"linear","fontSizeMode":"relative","fontCSS":{"family":"Departure Mono","src":"https://assets.unicorn.studio/fonts/studio_picks/DepartureMono/DepartureMono-Regular.woff"},"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"text","windowWidth":1440},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.25,"trackMouse":0.5,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }vec3 drawLine(vec2 uv, vec2 center, float scale, float angle) { float radAngle = -angle * TWO_PI; float phase = fract(uTime * 0.01 + 0.5000) * (3. * max(1., scale)) - (1.5 * max(1., scale));vec2 direction = vec2(cos(radAngle), sin(radAngle));vec2 centerToPoint = uv - center;float projection = dot(centerToPoint, direction);float distToLine = length(centerToPoint - projection * direction);float lineRadius = 0.0400 * 0.25; float brightness = lineRadius / (1. - smoothstep(0.4, 0., distToLine + 0.02));float glowRadius = scale; float glow = smoothstep(glowRadius, 0.0, abs(projection - phase));return brightness * (1.-distToLine)*(1.-distToLine) * vec3(0.5843137254901961, 0.3333333333333333, 1) * glow; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.4923245614035088, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.5000); return drawLine(uv, pos, 0.4900, 0.2500); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.0000); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"replicate","usesPingPong":false,"speed":0.08,"texture":false,"parentLayer":"71bb708a-ecd8-48d4-8919-1175e974b5e0","animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime;uniform vec2 uResolution;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float rotation = (-0.2500 * 2. * 3.141592653); float aspectRatio = uResolution.x/uResolution.y; vec2 aberrated = vec2(0); vec4 col = vec4(0); float repeatSpacing = 1.8000 * 0.35 * mix(1., aspectRatio, 0.5); float time = (uTime * 0.025) / (repeatSpacing + 0.001);for(float i = 0.; i < 16.0000; i++){ float offset = repeatSpacing * (i - 16.0000/2. + fract(time)); aberrated = vec2(offset * sin(rotation), offset * cos(rotation)); col += texture(uTexture, uv + aberrated) * (1. - col.a); } fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"voronoi","usesPingPong":false,"speed":1,"trackMouse":0.5,"mouseMomentum":0,"texture":false,"parentLayer":"7a55e45c-6061-49ef-a501-c6b0a931022a","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t < 0.5 ? (1.0 - sqrt(1.0 - 4.0 * t * t)) / 2.0 : (sqrt(-((2.0 * t) - 3.0) * ((2.0 * t) - 1.0)) + 1.0) / 2.0; } vec2 random2( vec2 p ) { return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } out vec4 fragColor; void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 skew = mix(vec2(1), vec2(1, 0), 0.5000);vec2 st = (uv - vec2(0.5, 0.5)) * vec2(aspectRatio, 1.) * 50. * 3.2800; st = st * rot(0.7500 * 2. * PI) * skew; vec2 i_st = floor(st); vec2 f_st = fract(st);float m_dist = 15.; vec2 m_point; vec2 d;for (int j=-1; j<=1; j++ ) { for (int i=-1; i<=1; i++ ) { vec2 neighbor = vec2(float(i),float(j)); vec2 point = random2(i_st + neighbor);point = 0.5 + 0.5 * sin(5. + uTime * 0.2 + 6.2831*point); vec2 diff = neighbor + point - f_st; float dist = length(diff);if( dist < m_dist ) { m_dist = dist; m_point = point; d = diff; } } }vec2 offset = (m_point * 0.2 * 0.9100 * 2.) - (0.9100 * 0.2);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.5000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(0.1000)); float dist = ease(15, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 0.1000)));vec4 color = texture(uTexture, uv + offset * dist); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"retro_screen","usesPingPong":false,"speed":0.25,"trackMouse":0.5,"mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime;uniform vec2 uResolution;out vec4 fragColor;vec3 styleOne(vec2 curvedUV) { float size = max(3.0 / 1080.0, 0.028 * (1.0 - 0.5900)); float aspectRatio = uResolution.x / uResolution.y; float aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5); vec2 cellSize = vec2(size / aspectRatio, size) * aspectCorrection;vec2 staggeredUV = curvedUV; if (mod(floor(curvedUV.x / cellSize.x), 2.0) > 0.5) { staggeredUV.y += 0.5 * cellSize.y; }vec2 cellCoords = floor(staggeredUV / cellSize) * cellSize;vec2 unstaggerOffset = vec2(0.0); if (mod(floor(curvedUV.x / cellSize.x), 2.0) > 0.5) { unstaggerOffset.y = -0.5 * cellSize.y; }vec2 sampleCoord = cellCoords + 0.5 * cellSize + unstaggerOffset; vec4 texColor = texture(uTexture, sampleCoord);vec2 staggeredCellPos = mod(staggeredUV, cellSize) / cellSize;float segmentWidth = 0.5; vec3 finalColor = vec3(0.0);float distCoord = staggeredCellPos.x;float distRed = abs(distCoord - segmentWidth * 0.5); float distGreen = abs(distCoord - segmentWidth * 1.); float distBlue = abs(distCoord - segmentWidth * 1.5);distRed = min(distRed, 1.0 - distRed); distGreen = min(distGreen, 1.0 - distGreen); distBlue = min(distBlue, 1.0 - distBlue);float softness = 0.75 * segmentWidth; float redFactor = smoothstep(softness, 0.0, distRed * 1.05); float greenFactor = smoothstep(softness, 0.0, distGreen * 1.1); float blueFactor = smoothstep(softness, 0.0, distBlue * 0.9);vec3 blurColor = vec3(0.0); float blurFactor = 1.0 / 9.0; for (int dx = -1; dx <= 1; dx++) { for (int dy = -1; dy <= 1; dy++) { vec2 offset = vec2(float(dx), dy) * cellSize * 0.3600; blurColor += texture(uTexture, sampleCoord + offset).rgb * blurFactor; } } finalColor.r = redFactor * blurColor.r * (3. * 0.8700); finalColor.g = greenFactor * blurColor.g * (3. * 0.8700); finalColor.b = blueFactor * blurColor.b * (3. * 0.8700);float edgeWidth = 0.05; vec2 edgeDistance = abs(staggeredCellPos - 0.5); float edgeFactor = smoothstep(0.45 - edgeWidth, 0.5, max(edgeDistance.x, edgeDistance.y)); edgeFactor = ((1.0 - edgeFactor) + 0.2); finalColor = finalColor * edgeFactor; finalColor = floor(finalColor * 64.0000) / 64.0000;float flicker = 1.0+0.03*cos(sampleCoord.x/6e1 + uTime*2e1); finalColor *= mix(1., flicker, 1.2000);return finalColor; }void main() { vec3 finalColor;vec4 color = texture(uTexture, vTextureCoord);if(color.a == 0.) { fragColor = vec4(0); return; }finalColor = styleOne(vTextureCoord);vec4 bg = texture(uTexture, vTextureCoord);vec4 col = mix(bg, vec4(finalColor, bg.a), 1.0000); fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"}],"options":{"name":"Particleizer","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.4.28","id":"EbDIGVtu1k0qbzUfOxYU"};
SCENE_CONFIG.options = { ...SCENE_CONFIG.options, includeLogo: false };

export default function UnicornStudioRawEmbed() {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneInitialized = useRef(false);

  useEffect(() => {
    let script = document.querySelector(`script[src='${UNICORN_SCRIPT_SRC}']`);
    let scriptAdded = false;
    if (!script) {
      script = document.createElement("script");
      (script as HTMLScriptElement).src = UNICORN_SCRIPT_SRC;
      (script as HTMLScriptElement).async = true;
      document.body.appendChild(script);
      scriptAdded = true;
    }

    const initializeScene = () => {
      if (window.UnicornStudio && containerRef.current && !sceneInitialized.current) {
        // Clear the container to prevent duplicate canvases
        containerRef.current.innerHTML = "";
        // Remove fps if present, to avoid type error
        const { fps, ...optionsWithoutFps } = SCENE_CONFIG.options || {};
        window.UnicornStudio.addScene({
          elementId: "unicorn-embed",
          ...optionsWithoutFps,
          projectId: SCENE_CONFIG.id,
        });
        sceneInitialized.current = true;
      }
    };

    if (script) {
      if (scriptAdded) {
        (script as HTMLScriptElement).onload = initializeScene;
      } else {
        if (window.UnicornStudio) {
          initializeScene();
        } else {
          script.addEventListener('load', initializeScene);
        }
      }
    }

    return () => {
      if (window.UnicornStudio) {
        window.UnicornStudio.destroy();
      }
      sceneInitialized.current = false;
      if (scriptAdded && script && script.parentNode) {
        script.parentNode.removeChild(script);
      }
    };
  }, []);

  // Bigger, responsive container
  return (
    <div
      id="unicorn-embed"
      ref={containerRef}
      style={{ width: 800, height: 600, margin: "0 auto" }}
    />
  );
} 